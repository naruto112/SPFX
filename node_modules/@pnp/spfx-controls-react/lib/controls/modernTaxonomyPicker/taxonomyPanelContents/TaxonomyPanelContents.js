var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import * as React from 'react';
import styles from './TaxonomyPanelContents.module.scss';
import { Checkbox } from 'office-ui-fabric-react/lib/Checkbox';
import { ChoiceGroup } from 'office-ui-fabric-react/lib/ChoiceGroup';
import { GroupedList, GroupHeader } from 'office-ui-fabric-react/lib/GroupedList';
import { Label } from 'office-ui-fabric-react/lib/Label';
import { Link } from 'office-ui-fabric-react/lib/Link';
import { Selection, SelectionMode } from 'office-ui-fabric-react/lib/Utilities';
import { Spinner } from 'office-ui-fabric-react/lib/Spinner';
import { SelectionZone } from 'office-ui-fabric-react/lib/Selection';
import { Guid } from '@microsoft/sp-core-library';
import { css } from '@uifabric/utilities/lib/css';
import * as strings from 'ControlStrings';
import { useForceUpdate } from '@uifabric/react-hooks';
import { ModernTermPicker } from '../modernTermPicker/ModernTermPicker';
export function TaxonomyPanelContents(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var _o = React.useState([]), groupsLoading = _o[0], setGroupsLoading = _o[1];
    var _p = React.useState([]), groups = _p[0], setGroups = _p[1];
    var _q = React.useState(((_a = props.selectedPanelOptions) === null || _a === void 0 ? void 0 : _a.length) > 0 ? __spreadArrays(props.selectedPanelOptions) : []), terms = _q[0], setTerms = _q[1];
    var forceUpdate = useForceUpdate();
    var selection = React.useMemo(function () {
        var s = new Selection({
            onSelectionChanged: function () {
                props.setSelectedPanelOptions(function (prevOptions) { return __spreadArrays(selection.getSelection()); });
                forceUpdate();
            }, getKey: function (term) { return term.id; }
        });
        s.setItems(terms);
        for (var _i = 0, _a = props.selectedPanelOptions; _i < _a.length; _i++) {
            var selectedOption = _a[_i];
            if (s.canSelectItem) {
                s.setKeySelected(selectedOption.id.toString(), true, true);
            }
        }
        return s;
    }, [terms]);
    React.useEffect(function () {
        var termRootName = "";
        if (props.anchorTermInfo) {
            var anchorTermNames = props.anchorTermInfo.labels.filter(function (name) { return name.languageTag === props.languageTag && name.isDefault; });
            if (anchorTermNames.length === 0) {
                anchorTermNames = props.anchorTermInfo.labels.filter(function (name) { return name.languageTag === props.termStoreInfo.defaultLanguageTag && name.isDefault; });
            }
            termRootName = anchorTermNames[0].name;
        }
        else {
            var termSetNames = props.termSetInfo.localizedNames.filter(function (name) { return name.languageTag === props.languageTag; });
            if (termSetNames.length === 0) {
                termSetNames = props.termSetInfo.localizedNames.filter(function (name) { return name.languageTag === props.termStoreInfo.defaultLanguageTag; });
            }
            termRootName = termSetNames[0].name;
        }
        var rootGroup = {
            name: termRootName,
            key: props.anchorTermInfo ? props.anchorTermInfo.id : props.termSetInfo.id,
            startIndex: -1,
            count: 50,
            level: 0,
            isCollapsed: false,
            data: { skiptoken: '' },
            hasMoreData: (props.anchorTermInfo ? props.anchorTermInfo.childrenCount : props.termSetInfo.childrenCount) > 0
        };
        setGroups([rootGroup]);
        setGroupsLoading(function (prevGroupsLoading) { return __spreadArrays(prevGroupsLoading, [props.termSetInfo.id]); });
        if (props.termSetInfo.childrenCount > 0) {
            props.onLoadMoreData(props.termSetId, props.anchorTermInfo ? Guid.parse(props.anchorTermInfo.id) : Guid.empty, '', true)
                .then(function (loadedTerms) {
                var grps = loadedTerms.value.map(function (term) {
                    var _a;
                    var termNames = term.labels.filter(function (termLabel) { return (termLabel.languageTag === props.languageTag && termLabel.isDefault === true); });
                    if (termNames.length === 0) {
                        termNames = term.labels.filter(function (termLabel) { return (termLabel.languageTag === props.termStoreInfo.defaultLanguageTag && termLabel.isDefault === true); });
                    }
                    var g = {
                        name: (_a = termNames[0]) === null || _a === void 0 ? void 0 : _a.name,
                        key: term.id,
                        startIndex: -1,
                        count: 50,
                        level: 1,
                        isCollapsed: true,
                        data: { skiptoken: '', term: term },
                        hasMoreData: term.childrenCount > 0,
                    };
                    if (g.hasMoreData) {
                        g.children = [];
                    }
                    return g;
                });
                setTerms(function (prevTerms) {
                    var nonExistingTerms = loadedTerms.value.filter(function (term) { return prevTerms.every(function (prevTerm) { return prevTerm.id !== term.id; }); });
                    return __spreadArrays(prevTerms, nonExistingTerms);
                });
                rootGroup.children = grps;
                rootGroup.data.skiptoken = loadedTerms.skiptoken;
                rootGroup.hasMoreData = loadedTerms.skiptoken !== '';
                setGroupsLoading(function (prevGroupsLoading) { return prevGroupsLoading.filter(function (value) { return value !== props.termSetId.toString(); }); });
                setGroups([rootGroup]);
            });
        }
    }, []);
    var onToggleCollapse = function (group) {
        if (group.isCollapsed === true) {
            setGroups(function (prevGroups) {
                var recurseGroups = function (currentGroup) {
                    var _a;
                    if (currentGroup.key === group.key) {
                        currentGroup.isCollapsed = false;
                    }
                    if (((_a = currentGroup.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        for (var _i = 0, _b = currentGroup.children; _i < _b.length; _i++) {
                            var child = _b[_i];
                            recurseGroups(child);
                        }
                    }
                };
                var newGroupsState = [];
                for (var _i = 0, prevGroups_1 = prevGroups; _i < prevGroups_1.length; _i++) {
                    var prevGroup = prevGroups_1[_i];
                    recurseGroups(prevGroup);
                    newGroupsState.push(prevGroup);
                }
                return newGroupsState;
            });
            if (group.children && group.children.length === 0) {
                setGroupsLoading(function (prevGroupsLoading) { return __spreadArrays(prevGroupsLoading, [group.key]); });
                group.data.isLoading = true;
                props.onLoadMoreData(props.termSetId, Guid.parse(group.key), '', true)
                    .then(function (loadedTerms) {
                    var grps = loadedTerms.value.map(function (term) {
                        var _a;
                        var termNames = term.labels.filter(function (termLabel) { return (termLabel.languageTag === props.languageTag && termLabel.isDefault === true); });
                        if (termNames.length === 0) {
                            termNames = term.labels.filter(function (termLabel) { return (termLabel.languageTag === props.termStoreInfo.defaultLanguageTag && termLabel.isDefault === true); });
                        }
                        var g = {
                            name: (_a = termNames[0]) === null || _a === void 0 ? void 0 : _a.name,
                            key: term.id,
                            startIndex: -1,
                            count: 50,
                            level: group.level + 1,
                            isCollapsed: true,
                            data: { skiptoken: '', term: term },
                            hasMoreData: term.childrenCount > 0,
                        };
                        if (g.hasMoreData) {
                            g.children = [];
                        }
                        return g;
                    });
                    setTerms(function (prevTerms) {
                        var nonExistingTerms = loadedTerms.value.filter(function (term) { return prevTerms.every(function (prevTerm) { return prevTerm.id !== term.id; }); });
                        return __spreadArrays(prevTerms, nonExistingTerms);
                    });
                    group.children = grps;
                    group.data.skiptoken = loadedTerms.skiptoken;
                    group.hasMoreData = loadedTerms.skiptoken !== '';
                    setGroupsLoading(function (prevGroupsLoading) { return prevGroupsLoading.filter(function (value) { return value !== group.key; }); });
                });
            }
        }
        else {
            setGroups(function (prevGroups) {
                var recurseGroups = function (currentGroup) {
                    var _a;
                    if (currentGroup.key === group.key) {
                        currentGroup.isCollapsed = true;
                    }
                    if (((_a = currentGroup.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        for (var _i = 0, _b = currentGroup.children; _i < _b.length; _i++) {
                            var child = _b[_i];
                            recurseGroups(child);
                        }
                    }
                };
                var newGroupsState = [];
                for (var _i = 0, prevGroups_2 = prevGroups; _i < prevGroups_2.length; _i++) {
                    var prevGroup = prevGroups_2[_i];
                    recurseGroups(prevGroup);
                    newGroupsState.push(prevGroup);
                }
                return newGroupsState;
            });
        }
    };
    var onRenderTitle = function (groupHeaderProps) {
        var _a;
        var isChildSelected = function (children) {
            var aChildIsSelected = children && children.some(function (child) { return selection.isKeySelected(child.key) || isChildSelected(child.children); });
            return aChildIsSelected;
        };
        var childIsSelected = isChildSelected(groupHeaderProps.group.children);
        if (groupHeaderProps.group.level === 0) {
            var labelStyles = { root: { fontWeight: childIsSelected ? "bold" : "normal" } };
            return (React.createElement(Label, { styles: labelStyles }, groupHeaderProps.group.name));
        }
        var isDisabled = groupHeaderProps.group.data.term.isAvailableForTagging.filter(function (t) { return t.setId === props.termSetId.toString(); })[0].isAvailable === false;
        var isSelected = selection.isKeySelected(groupHeaderProps.group.key);
        var selectionProps = {
            "data-selection-index": selection.getItems().findIndex(function (term) { return term.id === groupHeaderProps.group.key; })
        };
        if (props.allowMultipleSelections) {
            if (isDisabled) {
                selectionProps["data-selection-disabled"] = true;
            }
            else {
                selectionProps["data-selection-toggle"] = true;
            }
            var selectedStyles = { root: { pointerEvents: 'none' } };
            if (isSelected || childIsSelected) {
                selectedStyles.label = { fontWeight: 'bold' };
            }
            else {
                selectedStyles.label = { fontWeight: 'normal' };
            }
            return (React.createElement("div", __assign({}, selectionProps),
                React.createElement(Checkbox, { key: groupHeaderProps.group.key, label: groupHeaderProps.group.name, checked: isSelected, styles: selectedStyles, disabled: isDisabled, onRenderLabel: function (p) { return React.createElement("span", { className: css(!isDisabled && styles.checkbox, isDisabled && styles.disabledCheckbox, isSelected && styles.selectedCheckbox), title: p.title }, p.label); } })));
        }
        else {
            var selectedStyle = isSelected || childIsSelected ? { root: { marginTop: 0 }, choiceFieldWrapper: { fontWeight: 'bold', } } : { root: { marginTop: 0 }, choiceFieldWrapper: { fontWeight: 'normal' } };
            var options = [{
                    key: groupHeaderProps.group.key,
                    text: groupHeaderProps.group.name,
                    styles: selectedStyle,
                    onRenderLabel: function (p) {
                        return React.createElement("span", { id: p.labelId, className: css(!isDisabled && styles.choiceOption, isDisabled && styles.disabledChoiceOption, isSelected && styles.selectedChoiceOption) }, p.text);
                    }
                }];
            if (isDisabled) {
                selectionProps["data-selection-disabled"] = true;
            }
            else {
                selectionProps["data-selection-select"] = true;
            }
            return (React.createElement("div", __assign({}, selectionProps),
                React.createElement(ChoiceGroup, { options: options, selectedKey: (_a = selection.getSelection()[0]) === null || _a === void 0 ? void 0 : _a.id, disabled: isDisabled })));
        }
    };
    var onRenderHeader = function (headerProps) {
        var _a;
        var groupHeaderStyles = {
            expand: { height: 42, visibility: !headerProps.group.children || headerProps.group.level === 0 ? "hidden" : "visible", fontSize: 14 },
            expandIsCollapsed: { visibility: !headerProps.group.children || headerProps.group.level === 0 ? "hidden" : "visible", fontSize: 14 },
            check: { display: 'none' },
            headerCount: { display: 'none' },
            groupHeaderContainer: { height: 36, paddingTop: 3, paddingBottom: 3, paddingLeft: 3, paddingRight: 3, alignItems: 'center', },
            root: { height: 42 },
        };
        return (React.createElement(GroupHeader, __assign({}, headerProps, { styles: groupHeaderStyles, onRenderTitle: onRenderTitle, onToggleCollapse: onToggleCollapse, indentWidth: 20, expandButtonProps: { style: { color: (_a = props.themeVariant) === null || _a === void 0 ? void 0 : _a.semanticColors.bodyText } } })));
    };
    var onRenderFooter = function (footerProps) {
        if ((footerProps.group.hasMoreData || footerProps.group.children && footerProps.group.children.length === 0) && !footerProps.group.isCollapsed) {
            if (groupsLoading.some(function (value) { return value === footerProps.group.key; })) {
                var spinnerStyles = { circle: { verticalAlign: 'middle' } };
                return (React.createElement("div", { className: styles.spinnerContainer },
                    React.createElement(Spinner, { styles: spinnerStyles })));
            }
            var linkStyles = { root: { fontSize: '14px', paddingLeft: (footerProps.groupLevel + 1) * 20 + 62 } };
            return (React.createElement("div", { className: styles.loadMoreContainer },
                React.createElement(Link, { onClick: function () {
                        setGroupsLoading(function (prevGroupsLoading) { return __spreadArrays(prevGroupsLoading, [footerProps.group.key]); });
                        props.onLoadMoreData(props.termSetId, footerProps.group.key === props.termSetId.toString() ? Guid.empty : Guid.parse(footerProps.group.key), footerProps.group.data.skiptoken, true)
                            .then(function (loadedTerms) {
                            var grps = loadedTerms.value.map(function (term) {
                                var _a;
                                var termNames = term.labels.filter(function (termLabel) { return (termLabel.languageTag === props.languageTag && termLabel.isDefault === true); });
                                if (termNames.length === 0) {
                                    termNames = term.labels.filter(function (termLabel) { return (termLabel.languageTag === props.termStoreInfo.defaultLanguageTag && termLabel.isDefault === true); });
                                }
                                var g = {
                                    name: (_a = termNames[0]) === null || _a === void 0 ? void 0 : _a.name,
                                    key: term.id,
                                    startIndex: -1,
                                    count: 50,
                                    level: footerProps.group.level + 1,
                                    isCollapsed: true,
                                    data: { skiptoken: '', term: term },
                                    hasMoreData: term.childrenCount > 0,
                                };
                                if (g.hasMoreData) {
                                    g.children = [];
                                }
                                return g;
                            });
                            setTerms(function (prevTerms) {
                                var nonExistingTerms = loadedTerms.value.filter(function (term) { return prevTerms.every(function (prevTerm) { return prevTerm.id !== term.id; }); });
                                return __spreadArrays(prevTerms, nonExistingTerms);
                            });
                            footerProps.group.children = __spreadArrays(footerProps.group.children, grps);
                            footerProps.group.data.skiptoken = loadedTerms.skiptoken;
                            footerProps.group.hasMoreData = loadedTerms.skiptoken !== '';
                            setGroupsLoading(function (prevGroupsLoading) { return prevGroupsLoading.filter(function (value) { return value !== footerProps.group.key; }); });
                        });
                    }, styles: linkStyles }, strings.ModernTaxonomyPickerLoadMoreText)));
        }
        return null;
    };
    var onRenderShowAll = function () {
        return null;
    };
    var groupProps = {
        onRenderFooter: onRenderFooter,
        onRenderHeader: onRenderHeader,
        showEmptyGroups: true,
        onRenderShowAll: onRenderShowAll,
    };
    var onPickerChange = function (items) {
        var itemsToAdd = items.filter(function (item) { return terms.every(function (term) { return term.id !== item.id; }); });
        setTerms(function (prevTerms) { return __spreadArrays(prevTerms, itemsToAdd); });
        selection.setItems(__spreadArrays(selection.getItems(), itemsToAdd), true);
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            if (selection.canSelectItem(item)) {
                selection.setKeySelected(item.id.toString(), true, false);
            }
        }
    };
    var termPickerStyles = { root: { paddingTop: 4, paddingBottom: 4, paddingRight: 4, minheight: 34 }, input: { minheight: 34 }, text: { minheight: 34, borderStyle: 'none', borderWidth: '0px' } };
    return (React.createElement("div", { className: styles.taxonomyPanelContents },
        React.createElement("div", { className: styles.taxonomyTreeSelector },
            React.createElement("div", null,
                React.createElement(ModernTermPicker, __assign({}, props.termPickerProps, { removeButtonAriaLabel: strings.ModernTaxonomyPickerRemoveButtonText, onResolveSuggestions: (_c = (_b = props.termPickerProps) === null || _b === void 0 ? void 0 : _b.onResolveSuggestions, (_c !== null && _c !== void 0 ? _c : props.onResolveSuggestions)), itemLimit: props.allowMultipleSelections ? undefined : 1, selectedItems: props.selectedPanelOptions, styles: (_e = (_d = props.termPickerProps) === null || _d === void 0 ? void 0 : _d.styles, (_e !== null && _e !== void 0 ? _e : termPickerStyles)), onChange: onPickerChange, getTextFromItem: props.getTextFromItem, pickerSuggestionsProps: (_g = (_f = props.termPickerProps) === null || _f === void 0 ? void 0 : _f.pickerSuggestionsProps, (_g !== null && _g !== void 0 ? _g : { noResultsFoundText: strings.ModernTaxonomyPickerNoResultsFound })), inputProps: (_j = (_h = props.termPickerProps) === null || _h === void 0 ? void 0 : _h.inputProps, (_j !== null && _j !== void 0 ? _j : {
                        'aria-label': props.placeHolder || strings.ModernTaxonomyPickerDefaultPlaceHolder,
                        placeholder: props.placeHolder || strings.ModernTaxonomyPickerDefaultPlaceHolder
                    })), onRenderSuggestionsItem: (_l = (_k = props.termPickerProps) === null || _k === void 0 ? void 0 : _k.onRenderSuggestionsItem, (_l !== null && _l !== void 0 ? _l : props.onRenderSuggestionsItem)), onRenderItem: (_m = props.onRenderItem, (_m !== null && _m !== void 0 ? _m : props.onRenderItem)), themeVariant: props.themeVariant })))),
        React.createElement(Label, { className: styles.taxonomyTreeLabel }, strings.ModernTaxonomyPickerTreeTitle),
        React.createElement("div", null,
            React.createElement(SelectionZone, { selectionMode: props.allowMultipleSelections ? SelectionMode.multiple : SelectionMode.single, selection: selection },
                React.createElement(GroupedList, { items: [], onRenderCell: null, groups: groups, groupProps: groupProps, onShouldVirtualize: function (p) { return false; } })))));
}
//# sourceMappingURL=TaxonomyPanelContents.js.map